{"ast":null,"code":"/**\r\n * WebSocket Client for DHSILED Command Center\r\n * Handles real-time communication with backend WebSocket server\r\n */\n\nclass WebSocketClient {\n  constructor(url) {\n    this.url = url;\n    this.ws = null;\n    this.reconnectInterval = 5000;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 10;\n    this.eventHandlers = new Map();\n    this.connected = false;\n    this.shouldReconnect = true;\n  }\n  connect() {\n    try {\n      console.log(`Connecting to WebSocket: ${this.url}`);\n      this.ws = new WebSocket(this.url);\n      this.ws.onopen = () => {\n        console.log('✓ WebSocket connected');\n        this.connected = true;\n        this.reconnectAttempts = 0;\n        this.emit('connected');\n      };\n      this.ws.onclose = event => {\n        console.log('WebSocket disconnected:', event.code, event.reason);\n        this.connected = false;\n        this.emit('disconnected');\n\n        // Attempt to reconnect\n        if (this.shouldReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {\n          this.reconnectAttempts++;\n          console.log(`Reconnecting... (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n          setTimeout(() => this.connect(), this.reconnectInterval);\n        } else if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n          console.error('Max reconnection attempts reached');\n          this.emit('connection-failed');\n        }\n      };\n      this.ws.onerror = error => {\n        console.error('WebSocket error:', error);\n        this.emit('error', error);\n      };\n      this.ws.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          this.handleMessage(data);\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n        }\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n      this.emit('error', error);\n    }\n  }\n  handleMessage(data) {\n    const messageType = data.type || 'message';\n\n    // Emit event based on message type\n    this.emit(messageType, data);\n\n    // Also emit a generic 'message' event\n    this.emit('message', data);\n  }\n  send(data) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      const message = typeof data === 'string' ? data : JSON.stringify(data);\n      this.ws.send(message);\n      return true;\n    } else {\n      console.warn('WebSocket is not connected. Message not sent.');\n      return false;\n    }\n  }\n  disconnect() {\n    this.shouldReconnect = false;\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.connected = false;\n  }\n  on(event, handler) {\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, []);\n    }\n    this.eventHandlers.get(event).push(handler);\n  }\n  off(event, handler) {\n    if (!this.eventHandlers.has(event)) return;\n    const handlers = this.eventHandlers.get(event);\n    const index = handlers.indexOf(handler);\n    if (index !== -1) {\n      handlers.splice(index, 1);\n    }\n  }\n  emit(event, ...args) {\n    if (!this.eventHandlers.has(event)) return;\n    const handlers = this.eventHandlers.get(event);\n    handlers.forEach(handler => {\n      try {\n        handler(...args);\n      } catch (error) {\n        console.error(`Error in event handler for '${event}':`, error);\n      }\n    });\n  }\n  isConnected() {\n    return this.connected && this.ws && this.ws.readyState === WebSocket.OPEN;\n  }\n  getReadyState() {\n    if (!this.ws) return 'CLOSED';\n    switch (this.ws.readyState) {\n      case WebSocket.CONNECTING:\n        return 'CONNECTING';\n      case WebSocket.OPEN:\n        return 'OPEN';\n      case WebSocket.CLOSING:\n        return 'CLOSING';\n      case WebSocket.CLOSED:\n        return 'CLOSED';\n      default:\n        return 'UNKNOWN';\n    }\n  }\n}\nexport default WebSocketClient;","map":{"version":3,"names":["WebSocketClient","constructor","url","ws","reconnectInterval","reconnectAttempts","maxReconnectAttempts","eventHandlers","Map","connected","shouldReconnect","connect","console","log","WebSocket","onopen","emit","onclose","event","code","reason","setTimeout","error","onerror","onmessage","data","JSON","parse","handleMessage","messageType","type","send","readyState","OPEN","message","stringify","warn","disconnect","close","on","handler","has","set","get","push","off","handlers","index","indexOf","splice","args","forEach","isConnected","getReadyState","CONNECTING","CLOSING","CLOSED"],"sources":["C:/Users/Admin/Desktop/dshield/dhsiled-system/command-center/src/services/websocket-client.js"],"sourcesContent":["/**\r\n * WebSocket Client for DHSILED Command Center\r\n * Handles real-time communication with backend WebSocket server\r\n */\r\n\r\nclass WebSocketClient {\r\n    constructor(url) {\r\n        this.url = url;\r\n        this.ws = null;\r\n        this.reconnectInterval = 5000;\r\n        this.reconnectAttempts = 0;\r\n        this.maxReconnectAttempts = 10;\r\n        this.eventHandlers = new Map();\r\n        this.connected = false;\r\n        this.shouldReconnect = true;\r\n    }\r\n\r\n    connect() {\r\n        try {\r\n            console.log(`Connecting to WebSocket: ${this.url}`);\r\n            this.ws = new WebSocket(this.url);\r\n\r\n            this.ws.onopen = () => {\r\n                console.log('✓ WebSocket connected');\r\n                this.connected = true;\r\n                this.reconnectAttempts = 0;\r\n                this.emit('connected');\r\n            };\r\n\r\n            this.ws.onclose = (event) => {\r\n                console.log('WebSocket disconnected:', event.code, event.reason);\r\n                this.connected = false;\r\n                this.emit('disconnected');\r\n\r\n                // Attempt to reconnect\r\n                if (this.shouldReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {\r\n                    this.reconnectAttempts++;\r\n                    console.log(`Reconnecting... (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\r\n                    setTimeout(() => this.connect(), this.reconnectInterval);\r\n                } else if (this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n                    console.error('Max reconnection attempts reached');\r\n                    this.emit('connection-failed');\r\n                }\r\n            };\r\n\r\n            this.ws.onerror = (error) => {\r\n                console.error('WebSocket error:', error);\r\n                this.emit('error', error);\r\n            };\r\n\r\n            this.ws.onmessage = (event) => {\r\n                try {\r\n                    const data = JSON.parse(event.data);\r\n                    this.handleMessage(data);\r\n                } catch (error) {\r\n                    console.error('Error parsing WebSocket message:', error);\r\n                }\r\n            };\r\n\r\n        } catch (error) {\r\n            console.error('Error creating WebSocket connection:', error);\r\n            this.emit('error', error);\r\n        }\r\n    }\r\n\r\n    handleMessage(data) {\r\n        const messageType = data.type || 'message';\r\n        \r\n        // Emit event based on message type\r\n        this.emit(messageType, data);\r\n        \r\n        // Also emit a generic 'message' event\r\n        this.emit('message', data);\r\n    }\r\n\r\n    send(data) {\r\n        if (this.ws && this.ws.readyState === WebSocket.OPEN) {\r\n            const message = typeof data === 'string' ? data : JSON.stringify(data);\r\n            this.ws.send(message);\r\n            return true;\r\n        } else {\r\n            console.warn('WebSocket is not connected. Message not sent.');\r\n            return false;\r\n        }\r\n    }\r\n\r\n    disconnect() {\r\n        this.shouldReconnect = false;\r\n        if (this.ws) {\r\n            this.ws.close();\r\n            this.ws = null;\r\n        }\r\n        this.connected = false;\r\n    }\r\n\r\n    on(event, handler) {\r\n        if (!this.eventHandlers.has(event)) {\r\n            this.eventHandlers.set(event, []);\r\n        }\r\n        this.eventHandlers.get(event).push(handler);\r\n    }\r\n\r\n    off(event, handler) {\r\n        if (!this.eventHandlers.has(event)) return;\r\n        \r\n        const handlers = this.eventHandlers.get(event);\r\n        const index = handlers.indexOf(handler);\r\n        \r\n        if (index !== -1) {\r\n            handlers.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    emit(event, ...args) {\r\n        if (!this.eventHandlers.has(event)) return;\r\n        \r\n        const handlers = this.eventHandlers.get(event);\r\n        handlers.forEach(handler => {\r\n            try {\r\n                handler(...args);\r\n            } catch (error) {\r\n                console.error(`Error in event handler for '${event}':`, error);\r\n            }\r\n        });\r\n    }\r\n\r\n    isConnected() {\r\n        return this.connected && this.ws && this.ws.readyState === WebSocket.OPEN;\r\n    }\r\n\r\n    getReadyState() {\r\n        if (!this.ws) return 'CLOSED';\r\n        \r\n        switch (this.ws.readyState) {\r\n            case WebSocket.CONNECTING:\r\n                return 'CONNECTING';\r\n            case WebSocket.OPEN:\r\n                return 'OPEN';\r\n            case WebSocket.CLOSING:\r\n                return 'CLOSING';\r\n            case WebSocket.CLOSED:\r\n                return 'CLOSED';\r\n            default:\r\n                return 'UNKNOWN';\r\n        }\r\n    }\r\n}\r\n\r\nexport default WebSocketClient;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}